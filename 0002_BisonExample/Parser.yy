
/* Put here code that needs to be copied verbatim to (nearly) the top of the generated
   parser. A word of warning: some code (e.g. code that relies on declarations generated
   by Bison) cannot be put here (at least, there is no guarantee that the result will
   compile).
   */
%code top
{
    #include <iostream>
    #include <string>
    using std::cout;
}

/* %require is needed to use more recent features of Bison, particularly where
   C++ is concerned.

   NOTE:
       It seems like %require just triggers a check for Bison's version, the
   idea being to not even attempt to generate a parser if the version requirement
   is not met, rather than to generate an error if any feature is used that is
   more recent than the '%require'd version.
   */
%require "3.8"

/* Since we want Bison to generate a C++ parser, we say so with the following
   */
%language "c++"

/* We want to use Bison's variant type to hold token values (they can be
   a variety of types, after all), so we specify 'variant' here. Specifying
   'union' instead would cause a union instead, which doesn't really cater to
   C++ constructors/destructors. And specifying 'union-directive' would force
   us to explicitly define the union that will contain token values (for 'variant'
   and 'union', Bison will construct the specification of the variant/union based on
   the types we specify for the tokens).
   */
%define api.value.type variant

/* A bit of explanation: yylex() (the function that the Bison-generated parser will
   call to retrieve tokens; it is expected to be defined by the user) has a normal
   signature of the form 'int yylex( value_type* yylval, ... )' (where 'value_type'
   is defined by Bison itself). This form receives a union/variant that it can populate
   with the token value, and it returns the token type ('token kind' in Bison speak).
   This is referred to as the 'split token' form in the docs (because it does not keep
   the token value and the token type together).
        With '%define api.token.constructor', yylex() will be expected to take the
   form 'parser::symbol_type yylex(...)', in which it will construct and return objects
   of type 'symbol_type' that contain at least the token type (and perhaps also the
   token value, location in a source file, etc.). This form is called the 'complete tokens'
   form on account of 'symbol_type' holding all token-related information together.
   This form also results in Bison generating functions of the form 'make_<token_kind>'
   that can generate 'symbol_type' objects from values with types corresponding to
   different token kinds.
        Why use this form? Mostly because it's convenient...

   NOTE:
   - 'symbol_type' is an actual class whose definition is generated by Bison, and it
     provides the methods 'symbol_kind_type kind/0' and 'const char* name/0'
   - The type 'symbol_kind_type' is an enum type created by Bison. The identifiers in this
     type are the names of the tokens created with %token
   */
%define api.token.constructor

/* 'api.location.file' sets the name of the header file that will contain the definitions
   of 'position' and 'location' (these classes hold location data for tokens and their
   definitions are normally generated by Bison inside the generated parser code). This is
   useful if we want to define yylex() outside the parser spec but also want to be able to
   use these classes.
   'api.location.include' tells Bison what the #include statement should look like for
   including the header file containing the token location classes. In our case it will
   be: #include "TokenLocations.h"
   */
%define api.location.file     "TokenLocations.h"
%define api.location.include  {"TokenLocations.h"}

/* %header tells Bison to generate a header file containing declarations that are used
   by the generated parser code (normally these declarations would go into the file containing
   the generated parser code but in some cases, we might want to use them in a scanner routine
   located elsewhere).
   %location explicitly tells Bison to enable location tracking mode (which is normally
   enabled *only* if the '@n' symbol is used in parser actions). If this mode is not enabled,
   Bison will not generate the definitions for the token location classes. This may be
   a problem e.g. in the case where we want the AST nodes to contain location info but we
   don't actually want to make use of it, say, in the semantic analysis but not in the parser
   itself.
   Together, these two directives tell Bison to always generate the token location classes
   and to put them separately in a header file

   NOTE:
   - We go through this trouble for C++, mainly, especially in the case of %locations)
   - It is worth reiterating that for C++ parsers, the token classes will be defined in
     the header file specified by 'api.location.file' and other declarations will be in
     the file named by %header
   - It seems that %header is a relatively recently addition (after v3.5, at least).
     Previously, it used to be called %defines (I'm not sure if they have the same semantics,
     though).
   */
%header "ParserHeader.h"
%locations

/* For C++ parsers, the core parser functionality is put inside a Bison-generated class
   that is named 'parser' by default. The 'api.parser.class' variable (Bison docs calls
   these things variables) can be used to set a (relatively) more meaningful name.
   */
%define api.parser.class {Parser}

/* Set the name of the file in which the code for the generated parser is put.
   */
%output "Parser.cpp"

/* 'parse.error' sets the verbosity of the error message that gets passed to Parser::error/2.
   When set to 'simple' (which is the default), the message is simply "syntax error".
   'verbose' and 'detailed' produce increasingly detailed error messages. If, however,
   we set it to 'custom', then a function 'yyreport_syntax_error()' (in C++, this is
   'yy::Parser::report_syntax_error()') is declared in the Bison-generated code and has
   to be defined. In this case, the parser will no longer generate the error message *OR*
   call Parser::error/2 (effectively, this means that we will have a bit more information
   at our disposal but we are also taking on more work related to reporting errors).
   */
%define parse.error custom

/* By default, Bison will treat the head symbol of the first rule as the start symbol.
   That can be changed with %start. Note that there is nothing special about the name
   of the symbol in question (I just picked the most obvious name here).
   */
%start startsym

/* %token declares a terminal and associates with it a type. As mentioned above, Bison
   notes the types of all tokens and creates a union/variant out of them. As also
   mentioned, if we had set 'api.value.type' to be 'union-directive' or if we had
   explicitly created a union using the %union directive, we would have to replace the
   types (e.g. 'int' in the following declaration) with the name of a member in said
   union (see 10.1.4.2) (for C++ this is all moot, though - it is easier to just use
   Bison's variants.

   NOTE:
   - Since we are using 'api.value.constructor', the creation of the NUMBER token will
     cause Bison to generate the function 'symbol_type make_NUMBER( int, ... )'
   - A terminal need not have a type associated with it if we don't need to store its
     value. For example, for a delimiter token like a colon (':'), we can say
     '%token COLON' and when we encounter a ':' in yylex(), we can simply call the
     make_TOKEN() function generated by Bison to return an associated symbol.
   - The string after the token name is called a 'string alias' for the token. Subsequently,
     we can use the string and the token name interchangeably. Also, yylex() is supposed
     to return (in some way) a token kind value that is associated with the token name,
     but it may be that we choose to use the string aliases rather than token names
     when crafting the rules (e.g. for readability). In this case, there needs to be way
     to map the value returned by yylex() to the string literal used in a rule.
   - We don't need to create an explicit token for the end-of-file - Bison will create
     a token kind YYEOF as well as a function make_YYEOF(), which we can use. In fact,
     even if we *do* create our own EOF token, we will still have to call make_YYEOF()
     from within yylex (otherwise, Bison will report a syntax error).
   - In this example, we *CAN* leave out the string alias for PLUS. However, if there
     is a syntax error that results from this token, the error message will contain
     the string "PLUS" rather than "+" (which is more meaningful and is why string
     aliases are encouraged).
   */
%token <int>          NUMBER "number";
%token                PLUS "+";

/* %nterm declares a non-terminal and associates with it a type. The purpose and semantics
   of this statement are similar to those of terminals created with %token. With non-
   terminals, however, there is no string alias (because it doesn't make sense here).
   */
%nterm <int> expression;
%nterm <int> startsym;

/* Because of the declaration of yylex(), this cannot be '%code top' (if we try to do that,
   it will show up before the inclusion of the parser header file, which will cause
   compilation of the generated parser to fail).
   */
%code
{
    // yylex() *HAS* to be put in the 'yy' namespace (because the generated parser
    // expects it there)
    namespace yy
    {
        Parser::symbol_type
        yylex();
    }
}

%%

/* In the following lines, 'startsym: expression YYEOF' is the rule (with 'startsym'
   being the 'head symbol'). Everything between the {} is C++ (although the $$ and $1
   may throw us off) and the semicolon at the end is necessary. More on the $$ and $1
   below...
   */
startsym: expression YYEOF         { $$ = $1;
                                     cout << "Final sum = " << $$ << '\n'; }
        ;

/* The following is the result of two rules that are joined by the '|' because they
   have the same head symbol (note, however, that each rule has its own actions).
   The $$ is a placeholder for (in our spec) a Bison variant that will hold a value
   corresponding to the head symbol. Similarly, $1, $2, $3, ... variants corresponding
   to the components in the body of the rule (so $1 is for 'expression', $2 is for "+"
   and $3 is for "NUMBER"). Note that setting $$ must be done explicitly (which makes
   sense since Bison cannot know how we might want to combine the components).
   */
expression: expression "+" NUMBER  { cout << "Sum: " << $$ << '\n';
                                     cout << "    Number 1: " << $1 << '\n';
                                     cout << "    Number 2: " << $3 << '\n';
                                     $$ = $1 + $3; }
          | NUMBER                 { $$ = $1;
                                     cout << "Sum: " << $$ << '\n'; }
          ;

%%

/* This part of the spec is reserved for code that we may want to put verbatim in
   the generated parser. A couple of use cases for this are:
   - We want to define functions that we will use *only* in the parser actions. In this
     case, it may be better to have the code be in the same file as the parser routine.
   - For simple parsers, we may want to have the generated parser be usable in a standalone
     fashion. In this case, it may be too cumbersome to have a separate file that contains
     the entry point of the program (which, for C/C++ is necessary to build programs). In
     this situation, we can define the entry point here (as we do below) and have Bison
     put it in the generated parser.
   */

yy::Parser::symbol_type
yy::yylex()
{
    static int sIdx = 0;

    // This is a dummy implementation that just generates the sequence: 10 + 37 <EOF>
    // (one symbol for every call)
    switch( sIdx )
    {
        case 0:
        {
            sIdx++;
            return Parser::make_NUMBER( 10, yy::location( yy::position( nullptr, 1, 1 ), yy::position( nullptr, 1, 10 ) ) );
        }
        case 1:
        {
            sIdx++;
            return Parser::make_PLUS( yy::location( yy::position( nullptr, 1, 11 ), yy::position( nullptr, 1, 13 ) ) );
        }
        case 2:
        {
            sIdx++;
            return Parser::make_NUMBER( 37, yy::location( yy::position( nullptr, 1, 14 ), yy::position( nullptr, 1, 20 ) ) );
        }
        default:
            return Parser::make_YYEOF( yy::location( yy::position( nullptr, 1, 21 ), yy::position( nullptr, 1, 21 ) ) );
    }
}

/* If yylex returns a token of such a type that there is no rule that matches what is in
   the parse stack, the parser will consider it a syntax error and call the following
   method. Note that this method does not come with a default definition.
   */
void
yy::Parser::error( yy::Parser::location_type const& loc, std::string const& message )
{
    cout << "Error message: " << message << '\n';
}

/* When 'parse.error' is set to 'custom', we *HAVE* to define this. Unfortunately, we
   cannot call error/2 inside this method, but the reason, sadly enough, is that error/2
   is not marked 'const' (this problem applies to C++, it seems, not C). Moreover, it
   seems like it has to be defined even if it cannot be used.
   */
void
yy::Parser::report_syntax_error( yy::Parser::context const& parseContext ) const
{
    cout << "Unexpected symbol: " << symbol_name( parseContext.token() )
         << " (" << parseContext.location().begin.line << ", "
         << parseContext.location().begin.column << ")\n";
}

/* As mentioned before, if we want the parser to be self-contained, we need to create an
   entry point (in C/C++, this is main() or main(int, char**)).
   Alternatively, we can also use the parser in our own application by simply including
   the generated header file (in our case, ParserHeader.h).
   */
int
main()
{
    // Using the parser is straightforward enough. We just instantiate the class and
    // call parse/0 (which returns 0 on success).
    yy::Parser parser;
    parser.parse();

    return 0;
}